<span class="hl slc">! TheComputer Language Benchmarks Game</span>
<span class="hl slc">!   http://shootout.alioth.debian.org/</span>
<span class="hl slc">!</span>
<span class="hl slc">! contributed by Steve Decker based on the version by Simon Geard</span>
<span class="hl slc">! September 2008, Simon Geard, Added OpenMP directives</span>
<span class="hl slc">!</span>
<span class="hl slc">! compilation:</span>
<span class="hl slc">!   g95 -O1 -fomit-frame-pointer -funroll-loops spectral_norm.f90</span>
<span class="hl slc">!   ifort -ipo -O3 -openmp spectral_norm.f90</span>
<span class="hl slc">!   gfortran -O3 -openmp spectral_norm.f90 (not tested)</span>

<span class="hl kwa">module</span> norm_subs
  <span class="hl kwa">implicit none</span>

  public <span class="hl sym">::</span> MultiplyAtAv
  public <span class="hl sym">::</span> dp

  private
  <span class="hl kwb">integer</span><span class="hl sym">,</span> <span class="hl kwa">parameter</span> <span class="hl sym">::</span> dp <span class="hl sym">=</span> <span class="hl kwd">selected_real_kind</span><span class="hl sym">(</span><span class="hl num">12</span><span class="hl sym">)</span>

<span class="hl kwa">contains</span>

  <span class="hl slc">! Multiply v by A</span>
  pure <span class="hl kwa">function</span> <span class="hl kwd">MultiplyAv</span><span class="hl sym">(</span>v<span class="hl sym">)</span> <span class="hl kwd">result</span> <span class="hl sym">(</span>Av<span class="hl sym">)</span>
    <span class="hl kwb">real</span><span class="hl sym">(</span>dp<span class="hl sym">),</span> <span class="hl kwa">dimension</span><span class="hl sym">(:),</span> <span class="hl kwd">intent</span><span class="hl sym">(</span>in<span class="hl sym">) ::</span> v
    <span class="hl kwb">real</span><span class="hl sym">(</span>dp<span class="hl sym">),</span> <span class="hl kwa">dimension</span><span class="hl sym">(</span><span class="hl kwd">size</span><span class="hl sym">(</span>v<span class="hl sym">))       ::</span> Av
    <span class="hl kwb">real</span><span class="hl sym">(</span>dp<span class="hl sym">) ::</span> r
    <span class="hl kwb">integer</span> <span class="hl sym">::</span> n<span class="hl sym">,</span> i<span class="hl sym">,</span> j

    n <span class="hl sym">=</span> <span class="hl kwd">size</span><span class="hl sym">(</span>v<span class="hl sym">)</span>
    <span class="hl slc">!$omp parallel do shared(Av, v, n) private(i, j, r)</span>
    <span class="hl kwa">do</span> i <span class="hl sym">=</span> <span class="hl num">1</span><span class="hl sym">,</span> n
       r <span class="hl sym">=</span> <span class="hl num">0.0d0</span>
       <span class="hl kwa">do</span> j <span class="hl sym">=</span> <span class="hl num">1</span><span class="hl sym">,</span> n
          r <span class="hl sym">=</span> r <span class="hl sym">+</span> <span class="hl kwd">A</span><span class="hl sym">() *</span> <span class="hl kwd">v</span><span class="hl sym">(</span>j<span class="hl sym">)</span>
       <span class="hl kwa">end do</span>
       <span class="hl kwd">Av</span><span class="hl sym">(</span>i<span class="hl sym">) =</span> r
    <span class="hl kwa">end do</span>
    <span class="hl slc">!omp end parallel do</span>

  <span class="hl kwa">contains</span>
    pure <span class="hl kwb">real</span><span class="hl sym">(</span>dp<span class="hl sym">)</span> <span class="hl kwa">function</span> A
      <span class="hl slc">! Return element i,j of infinite matrix A</span>
      a <span class="hl sym">=</span> <span class="hl num">1</span><span class="hl sym">.</span>d0 <span class="hl sym">/ ((</span>i<span class="hl sym">+</span>j<span class="hl sym">-</span><span class="hl num">2</span><span class="hl sym">) * (</span>i<span class="hl sym">+</span>j<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">)/</span><span class="hl num">2</span> <span class="hl sym">+</span> i<span class="hl sym">)</span>
    <span class="hl kwa">end function</span> A
  <span class="hl kwa">end function</span> MultiplyAv

  <span class="hl slc">! Multiply v by A transpose</span>
  pure <span class="hl kwa">function</span> <span class="hl kwd">MultiplyAtv</span><span class="hl sym">(</span>v<span class="hl sym">)</span> <span class="hl kwd">result</span> <span class="hl sym">(</span>Atv<span class="hl sym">)</span>
    <span class="hl kwb">real</span><span class="hl sym">(</span>dp<span class="hl sym">),</span> <span class="hl kwa">dimension</span><span class="hl sym">(:),</span> <span class="hl kwd">intent</span><span class="hl sym">(</span>in<span class="hl sym">) ::</span> v
    <span class="hl kwb">real</span><span class="hl sym">(</span>dp<span class="hl sym">),</span> <span class="hl kwa">dimension</span><span class="hl sym">(</span><span class="hl kwd">size</span><span class="hl sym">(</span>v<span class="hl sym">))       ::</span> Atv

    <span class="hl kwb">real</span><span class="hl sym">(</span>dp<span class="hl sym">) ::</span> r
    <span class="hl kwb">integer</span> <span class="hl sym">::</span> n<span class="hl sym">,</span> i<span class="hl sym">,</span> j

    n <span class="hl sym">=</span> <span class="hl kwd">size</span><span class="hl sym">(</span>v<span class="hl sym">)</span>
    Atv <span class="hl sym">=</span> <span class="hl num">0</span><span class="hl sym">.</span>d0
    <span class="hl slc">!$omp parallel do shared(Atv, v, n) private(i, j, r)</span>
    <span class="hl kwa">do</span> i <span class="hl sym">=</span> <span class="hl num">1</span><span class="hl sym">,</span> n
       r <span class="hl sym">=</span> <span class="hl num">0.0d0</span>
       <span class="hl kwa">do</span> j <span class="hl sym">=</span> <span class="hl num">1</span><span class="hl sym">,</span> n
          r <span class="hl sym">=</span> r <span class="hl sym">+</span> <span class="hl kwd">AT</span><span class="hl sym">() *</span> <span class="hl kwd">v</span><span class="hl sym">(</span>j<span class="hl sym">)</span>
       <span class="hl kwa">end do</span>
       <span class="hl kwd">Atv</span><span class="hl sym">(</span>i<span class="hl sym">) =</span> r
    <span class="hl kwa">end do</span>
    <span class="hl slc">!omp end parallel do</span>

  <span class="hl kwa">contains</span>
    pure <span class="hl kwb">real</span><span class="hl sym">(</span>dp<span class="hl sym">)</span> <span class="hl kwa">function</span> AT
      <span class="hl slc">! Return element j,i of infinite matrix A</span>
      AT <span class="hl sym">=</span> <span class="hl num">1</span><span class="hl sym">.</span>d0 <span class="hl sym">/ ((</span>i<span class="hl sym">+</span>j<span class="hl sym">-</span><span class="hl num">2</span><span class="hl sym">) * (</span>i<span class="hl sym">+</span>j<span class="hl sym">-</span><span class="hl num">1</span><span class="hl sym">)/</span><span class="hl num">2</span> <span class="hl sym">+</span> j<span class="hl sym">)</span>
    <span class="hl kwa">end function</span> AT
  <span class="hl kwa">end function</span> MultiplyAtv

  <span class="hl slc">! Multiply v by A and then by A transpose</span>
  pure <span class="hl kwa">function</span> <span class="hl kwd">MultiplyAtAv</span><span class="hl sym">(</span>v<span class="hl sym">)</span> <span class="hl kwd">result</span> <span class="hl sym">(</span>AtAv<span class="hl sym">)</span>
    <span class="hl kwb">real</span><span class="hl sym">(</span>dp<span class="hl sym">),</span> <span class="hl kwa">dimension</span><span class="hl sym">(:),</span> <span class="hl kwd">intent</span><span class="hl sym">(</span>in<span class="hl sym">) ::</span> v
    <span class="hl kwb">real</span><span class="hl sym">(</span>dp<span class="hl sym">),</span> <span class="hl kwa">dimension</span><span class="hl sym">(</span><span class="hl kwd">size</span><span class="hl sym">(</span>v<span class="hl sym">))       ::</span> AtAv

    AtAv <span class="hl sym">=</span> <span class="hl kwd">MultiplyAtv</span><span class="hl sym">(</span><span class="hl kwd">MultiplyAv</span><span class="hl sym">(</span>v<span class="hl sym">))</span>
  <span class="hl kwa">end function</span> MultiplyAtAv
<span class="hl kwa">end module</span> norm_subs

<span class="hl kwa">program</span> spectral_norm
  <span class="hl kwa">use</span> norm_subs
  <span class="hl kwa">implicit none</span>

  <span class="hl kwb">real</span><span class="hl sym">(</span>dp<span class="hl sym">),</span> <span class="hl kwa">dimension</span><span class="hl sym">(:),</span> allocatable <span class="hl sym">::</span> u<span class="hl sym">,</span> v
  <span class="hl kwb">integer</span>          <span class="hl sym">::</span> i<span class="hl sym">,</span> n
  <span class="hl kwb">character</span><span class="hl sym">(</span>len<span class="hl sym">=</span><span class="hl num">6</span><span class="hl sym">) ::</span> argv

  <span class="hl kwb">integer</span><span class="hl sym">,</span> <span class="hl kwa">external</span> <span class="hl sym">::</span> omp_get_num_procs

  <span class="hl slc">! By default the number of threads should be set to the number of processors</span>
  <span class="hl slc">! but the number can be controlled with one of the folowing</span>
  <span class="hl slc">! export OMP_NUM_THREADS=4</span>
  <span class="hl slc">! call omp_set_num_threads(omp_get_num_procs())</span>

  <span class="hl kwa">call</span> <span class="hl kwd">get_command_argument</span><span class="hl sym">(</span><span class="hl num">1</span><span class="hl sym">,</span> argv<span class="hl sym">)</span>
  <span class="hl kwa">read</span><span class="hl sym">(</span>argv<span class="hl sym">, *)</span> n

  <span class="hl kwd">allocate</span><span class="hl sym">(</span><span class="hl kwd">u</span><span class="hl sym">(</span>n<span class="hl sym">),</span> <span class="hl kwd">v</span><span class="hl sym">(</span>n<span class="hl sym">))</span>
  u <span class="hl sym">=</span> <span class="hl num">1</span><span class="hl sym">.</span>d0
  <span class="hl kwa">do</span> i <span class="hl sym">=</span> <span class="hl num">1</span><span class="hl sym">,</span> <span class="hl num">10</span>
     v <span class="hl sym">=</span> <span class="hl kwd">MultiplyAtAv</span><span class="hl sym">(</span>u<span class="hl sym">)</span>
     u <span class="hl sym">=</span> <span class="hl kwd">MultiplyAtAv</span><span class="hl sym">(</span>v<span class="hl sym">)</span>
  <span class="hl kwa">end do</span>

  <span class="hl kwa">write</span><span class="hl sym">(*,</span> <span class="hl str">&quot;(f0.9)&quot;</span><span class="hl sym">)</span> <span class="hl kwd">sqrt</span><span class="hl sym">(</span><span class="hl kwd">dot_product</span><span class="hl sym">(</span>u<span class="hl sym">,</span>v<span class="hl sym">) /</span> <span class="hl kwd">dot_product</span><span class="hl sym">(</span>v<span class="hl sym">,</span>v<span class="hl sym">))</span>
  <span class="hl kwd">deallocate</span><span class="hl sym">(</span>u<span class="hl sym">,</span> v<span class="hl sym">)</span>
<span class="hl kwa">end program</span> spectral_norm
