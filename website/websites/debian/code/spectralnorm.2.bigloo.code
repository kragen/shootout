<span class="sym">(</span>module spectral<span class="sym">-</span>norm
   <span class="sym">(</span>main main<span class="sym">))</span>

<span class="sym">(</span>define<span class="sym">-</span>syntax contract
   <span class="sym">(</span>syntax<span class="sym">-</span>rules <span class="sym">()</span>
      <span class="sym">((</span>contract <span class="sym">(</span>i n<span class="sym">)</span> t1 t2<span class="sym">)</span>
       <span class="sym">(</span>do <span class="sym">((</span>i <span class="num">0</span> <span class="sym">(+</span>fx i <span class="num">1</span><span class="sym">))</span>
	    <span class="sym">(</span>sum <span class="num">0.0</span> <span class="sym">(+</span>fl sum <span class="sym">(*</span>fl t1 t2<span class="sym">))))</span>
	   <span class="sym">((=</span>fx i n<span class="sym">)</span> sum<span class="sym">)))))</span>

<span class="slc">;;; (indexed-expression-&gt;vector ((i 4) (j 4)) (g i j)) =&gt;</span>
<span class="slc">;;; #( #(g00 g01 g02 g03) #(g10 g11 g12 g13) ... )</span>
<span class="sym">(</span>define<span class="sym">-</span>syntax indexed<span class="sym">-</span>expression<span class="sym">-&gt;</span>vector
   <span class="sym">(</span>syntax<span class="sym">-</span>rules <span class="sym">()</span>
      <span class="sym">((</span>indexed<span class="sym">-</span>expression<span class="sym">-&gt;</span>vector <span class="sym">((</span>i n<span class="sym">))</span> body ...<span class="sym">)</span>
       <span class="sym">(</span>let <span class="sym">((</span>result <span class="sym">(</span>make<span class="sym">-</span>vector n <span class="sym">(</span>let <span class="sym">((</span>i <span class="num">0</span><span class="sym">))</span> body ...<span class="sym">))))</span>
	  <span class="sym">(</span>do <span class="sym">((</span>i <span class="num">1</span> <span class="sym">(+</span>fx i <span class="num">1</span><span class="sym">)))</span>
	      <span class="sym">((=</span>fx i n<span class="sym">)</span> result<span class="sym">)</span>
	      <span class="sym">(</span>vector<span class="sym">-</span><span class="kwa">set</span><span class="sym">!</span> result i <span class="sym">(</span>begin body ...<span class="sym">)))))</span>
      <span class="sym">((</span>indexed<span class="sym">-</span>expression<span class="sym">-&gt;</span>vector <span class="sym">((</span>i n<span class="sym">) (</span>j m<span class="sym">)</span> ...<span class="sym">)</span> body ...<span class="sym">)</span>
       <span class="sym">(</span>indexed<span class="sym">-</span>expression<span class="sym">-&gt;</span>vector <span class="sym">((</span>i n<span class="sym">))</span>
				   <span class="sym">(</span>indexed<span class="sym">-</span>expression<span class="sym">-&gt;</span>vector
				    <span class="sym">((</span>j m<span class="sym">)</span> ...<span class="sym">)</span> body ...<span class="sym">)))))</span>

<span class="slc">;;; Like indexed-expression-&gt;vector, but without creating a new</span>
<span class="slc">;;; vector.</span>
<span class="sym">(</span>define<span class="sym">-</span>syntax indexed<span class="sym">-</span>expression<span class="sym">-</span>into<span class="sym">-</span>vector
   <span class="sym">(</span>syntax<span class="sym">-</span>rules <span class="sym">()</span>
      <span class="sym">((</span>indexed<span class="sym">-</span>expression<span class="sym">-</span>into<span class="sym">-</span>vector v <span class="sym">((</span>i n<span class="sym">))</span> body ...<span class="sym">)</span>
       <span class="sym">(</span>do <span class="sym">((</span>i <span class="num">0</span> <span class="sym">(+</span>fx i <span class="num">1</span><span class="sym">)))</span>
	   <span class="sym">((=</span>fx i n<span class="sym">)</span> v<span class="sym">)</span>
	   <span class="sym">(</span>vector<span class="sym">-</span><span class="kwa">set</span><span class="sym">!</span> v i <span class="sym">(</span>begin body ...<span class="sym">))))</span>
      <span class="sym">((</span>indexed<span class="sym">-</span>expression<span class="sym">-</span>into<span class="sym">-</span>vector v <span class="sym">((</span>i n<span class="sym">) (</span>j m<span class="sym">)</span> ...<span class="sym">)</span> body ...<span class="sym">)</span>
       <span class="sym">(</span>do <span class="sym">((</span>i <span class="num">0</span> <span class="sym">(+</span>fx i <span class="num">1</span><span class="sym">)))</span>
	   <span class="sym">((=</span>fx i n<span class="sym">)</span> v<span class="sym">)</span>
	   <span class="sym">(</span>indexed<span class="sym">-</span>expression<span class="sym">-</span>into<span class="sym">-</span>vector <span class="sym">(</span>vector<span class="sym">-</span>ref v i<span class="sym">)</span>
					   <span class="sym">((</span>j m<span class="sym">)</span> ...<span class="sym">)</span> body ...<span class="sym">)))))</span>

<span class="slc">;;; If v is a two-indexed vector (i.e. a vector of vectors), then</span>
<span class="slc">;;; (% v i j) =&gt; (vector-ref (vector-ref v i) j)</span>
<span class="sym">(</span>define<span class="sym">-</span>syntax %
   <span class="sym">(</span>syntax<span class="sym">-</span>rules <span class="sym">()</span>
      <span class="sym">((</span>index<span class="sym">-</span>vector v i<span class="sym">)</span>
       <span class="sym">(</span>vector<span class="sym">-</span>ref v i<span class="sym">))</span>
      <span class="sym">((</span>index<span class="sym">-</span>vector v i j ...<span class="sym">)</span>
       <span class="sym">(</span>index<span class="sym">-</span>vector <span class="sym">(</span>vector<span class="sym">-</span>ref v i<span class="sym">)</span> j ...<span class="sym">))))</span>

<span class="sym">(</span>define <span class="sym">(</span>int<span class="sym">-&gt;</span>double<span class="sym">::</span>double i<span class="sym">::</span>int<span class="sym">)</span>
   <span class="sym">(</span>free<span class="sym">-</span>pragma<span class="sym">::</span>double <span class="str">&quot;((double) ($1))&quot;</span> i<span class="sym">))</span>

<span class="sym">(</span>define <span class="sym">(</span>A<span class="sym">::</span>double i<span class="sym">::</span>int j<span class="sym">::</span>int<span class="sym">)</span>
   <span class="sym">(/</span>fl <span class="num">1.0</span> <span class="sym">(</span>int<span class="sym">-&gt;</span>double
	     <span class="sym">(+</span>fx i <span class="sym">(+</span>fx <span class="num">1</span> <span class="sym">(/</span>fx <span class="sym">(*</span>fx <span class="sym">(+</span> i j<span class="sym">)</span>
				     <span class="sym">(+</span> i j <span class="num">1</span><span class="sym">))</span>
				<span class="num">2</span><span class="sym">))))))</span>



<span class="sym">(</span>define <span class="sym">(</span>produce<span class="sym">-</span>u19<span class="sym">-</span><span class="kwa">and</span><span class="sym">-</span>u20 n<span class="sym">::</span>int<span class="sym">)</span>
   <span class="sym">(</span>let loop <span class="sym">((</span>i <span class="num">0</span><span class="sym">) (</span>v1 <span class="sym">(</span>make<span class="sym">-</span>vector n <span class="num">1.0</span><span class="sym">))</span>
		    <span class="sym">(</span>v2 <span class="sym">(</span>make<span class="sym">-</span>vector n <span class="num">0.0</span><span class="sym">)))</span>
      <span class="sym">(</span><span class="kwa">if</span> <span class="sym">(=</span>fx i <span class="num">20</span><span class="sym">)</span>
	  <span class="sym">(</span>values v2 v1<span class="sym">)</span>
	  <span class="sym">(</span>begin
	     <span class="sym">(</span>let <span class="sym">((</span>storage <span class="sym">(</span>indexed<span class="sym">-</span>expression<span class="sym">-&gt;</span>vector
			     <span class="sym">((</span>j n<span class="sym">)) (</span>contract <span class="sym">(</span>k n<span class="sym">) (</span>A j k<span class="sym">) (</span>% v1 k<span class="sym">)))))</span>
		<span class="sym">(</span>indexed<span class="sym">-</span>expression<span class="sym">-</span>into<span class="sym">-</span>vector
		 v2 <span class="sym">((</span>j n<span class="sym">))</span>
		 <span class="sym">(</span>contract <span class="sym">(</span>k n<span class="sym">) (</span>A k j<span class="sym">) (</span>% storage k<span class="sym">))))</span>
	     <span class="sym">(</span>loop <span class="sym">(+</span>fx i <span class="num">1</span><span class="sym">)</span> v2 v1<span class="sym">)))))</span>

<span class="sym">(</span>define <span class="sym">(</span>main argv<span class="sym">)</span>
   <span class="sym">(</span>let <span class="sym">((</span>n<span class="sym">::</span>int <span class="sym">(</span>string<span class="sym">-&gt;</span>number <span class="sym">(</span><span class="kwa">cadr</span> argv<span class="sym">))))</span>
      <span class="sym">(</span>multiple<span class="sym">-</span>value<span class="sym">-</span>bind
	    <span class="sym">(</span>u19 u20<span class="sym">) (</span>produce<span class="sym">-</span>u19<span class="sym">-</span><span class="kwa">and</span><span class="sym">-</span>u20 n<span class="sym">)</span>
	    <span class="sym">(</span>display <span class="sym">(</span><span class="kwa">sqrt</span> <span class="sym">(/</span>fl <span class="sym">(</span>contract <span class="sym">(</span>i n<span class="sym">) (</span>% u20 i<span class="sym">) (</span>% u19 i<span class="sym">))</span>
				<span class="sym">(</span>contract <span class="sym">(</span>i n<span class="sym">) (</span>% u19 i<span class="sym">) (</span>% u19 i<span class="sym">)))))</span>
	    <span class="sym">(</span>newline<span class="sym">))))</span>
